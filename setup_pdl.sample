#!/bin/bash

# Exit on any error
set -e

echo "=================================="
echo " Instalandoo GetText"
echo "=================================="

# instala o gettext
sudo apt update
sudo apt upgrade -y
sudo apt-get install --reinstall gettext

echo "=================================="
echo " Instalando Docker e Docker Compose"
echo "=================================="

# Atualiza pacotes e instala dependências
sudo apt update
sudo apt install -y apt-transport-https ca-certificates curl software-properties-common

# Adiciona chave GPG do Docker
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -

# Adiciona repositório Docker (Ubuntu 22.x usa 'jammy' no lugar de 'focal')
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu jammy stable"

# Instala Docker CE
sudo apt update
sudo apt install -y docker-ce

# Ativa Docker no boot
sudo systemctl enable docker
sudo systemctl start docker

# Verifica instalação do Docker
docker --version

echo "=================================="
echo " Instalando Docker Compose"
echo "=================================="

# Baixa Docker Compose
sudo curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose

# Dá permissão de execução
sudo chmod +x /usr/local/bin/docker-compose

# Verifica instalação do Docker Compose
docker-compose --version

echo "=================================="
echo " Instalando e configurando o PDL"
echo "=================================="

# Clona repositório
git clone https://github.com/D3NKYT0/lineage.git .
echo "Repositório clonado."

# Cria install.sh básico
cat <<EOL > install.sh
#!/bin/bash

set -e

echo "=============================="
echo "Preparing local environment"
echo "=============================="

# Verifica se Python 3.10+ está disponível
echo "Checking Python version..."
PYTHON_VERSION=$(python3 -c 'import sys; print(".".join(map(str, sys.version_info[:2])))')
REQUIRED_VERSION="3.10"

version_compare() {
  [ "$(printf '%s\n' "$@" | sort -V | head -n 1)" = "$1" ]
}

if version_compare "$REQUIRED_VERSION" "$PYTHON_VERSION"; then
  echo "Python $PYTHON_VERSION found"
else
  echo "Python 3.10+ required, found $PYTHON_VERSION"
  exit 1
fi

# Instala venv e pip se necessário
echo "Installing python3-venv and pip (if needed)..."
sudo apt update
sudo apt install -y python3-venv python3-pip

# Cria o .venv se não existir
if [ ! -d ".venv" ]; then
  echo "Creating virtual environment..."
  python3 -m venv .venv
else
  echo "Virtual environment already exists"
fi

# Ativa o ambiente
echo "Activating virtual environment..."
source .venv/bin/activate

# Atualiza pip e instala requirements
echo "Installing requirements..."
pip install --upgrade pip
pip install -r requirements.txt

# Garante que o diretório de logs existe
echo "Ensuring required folders exist..."
mkdir -p logs

echo "Environment is ready to use."
EOL

# Cria build.sh básico
cat <<EOL > build.sh
#!/bin/bash

# Exit on any error
set -e

echo "=============================="
echo "Starting deployment process"
echo "=============================="

# Pull latest changes from Git
echo "Pulling latest changes from Git..."
git pull origin main || { echo "Failed to pull from Git repository"; exit 1; }

# Activate virtualenv (must exist)
echo "Activating virtual environment..."
source .venv/bin/activate || { echo "Virtualenv not found. Please create it with 'python -m venv .venv'"; exit 1; }

# Upgrade installed packages from requirements.txt
echo "Upgrading packages from requirements.txt..."
pip install -U -r requirements.txt || { echo "Failed to upgrade packages"; exit 1; }

# Check Django project for issues
echo "Running Django system check (host)..."
python3 manage.py check || { echo "Django check failed"; exit 1; }

# Create new migrations locally
echo "Making migrations (host)..."
python3 manage.py makemigrations || { echo "Failed to make migrations"; exit 1; }

# Stop running containers
echo "Stopping containers..."
docker compose down || { echo "Failed to stop running containers"; }

# Remove old containers
echo "Removing old containers..."
containers=$(docker ps -a -q --filter name=site --filter name=celery --filter name=celery_beat --filter name=flower --filter name=nginx --filter name=redis)
if [ -n "$containers" ]; then
  docker rm $containers || echo "Some containers could not be removed (maybe already removed)"
else
  echo "No containers found to remove."
fi

# Remove optional static_data volume
echo "Removing static_data volume..."
docker volume rm $(docker volume ls -q --filter name=static_data) || echo "Volume not found or already removed"

# Build Docker images
echo "Building Docker images..."
docker compose build || { echo "Failed to build Docker images"; exit 1; }

# Start containers
echo "Starting containers..."
docker compose up -d || { echo "Failed to start containers"; exit 1; }

# Wait for DB (direct)
echo "Waiting for database..."
until docker compose exec postgres pg_isready -U db_user > /dev/null 2>&1; do
  echo "$(date '+%H:%M:%S') - PostgreSQL is not ready yet. Waiting..."
  sleep 2
done

# Run migration inside container (applies what was created on host)
echo "Applying migrations inside container..."
docker compose exec site python3 manage.py migrate || { echo "Failed to apply migrations"; exit 1; }

# Clean up
echo "Cleaning up..."
docker image prune -f
docker volume prune -f
docker container prune -f
docker builder prune -f

echo "Deployment completed successfully."
EOL

# Dá permissão de execução
chmod +x install.sh build.sh

# Cria arquivo .env vazio (caso não exista)
touch .env
echo ".env criado (preencha manualmente)"

echo "=================================="
echo " Executando install.sh e build.sh"
echo "=================================="

./install.sh

echo "=================================="
echo " Instalação e configuração concluídas!"
echo "=================================="
